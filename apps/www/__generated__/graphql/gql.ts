/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "\n  \n  query getArticleRecommendations($path: String!) {\n    article: document(path: $path) {\n      id\n      meta {\n        recommendations {\n          nodes {\n            ...FeedDocument\n          }\n        }\n      }\n    }\n  }\n": types.GetArticleRecommendationsDocument,
    "\n  fragment AudioQueueItemFragment on AudioQueueItem {\n    id\n    sequence\n    document {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioCoverCrop {\n          x\n          y\n          width\n          height\n        }\n        coverForNativeApp: audioCover(properties: { width: 1024, height: 1024 })\n        coverMd: audioCover(properties: { width: 256, height: 256 })\n        coverSm: audioCover(properties: { width: 128, height: 128 })\n        audioSource {\n          mediaId\n          kind\n          mp3\n          aac\n          ogg\n          durationMs\n        }\n        format {\n          id\n          meta {\n            title\n            color\n            shareLogo\n            shareBackgroundImage\n            shareBackgroundImageInverted\n          }\n        }\n      }\n    }\n  }\n": types.AudioQueueItemFragmentFragmentDoc,
    "\n  query GetAudioQueue {\n    me {\n      id\n      audioQueue {\n        ...AudioQueueItemFragment\n      }\n    }\n  }\n  \n": types.GetAudioQueueDocument,
    "\n  mutation AddPlaylistItem($entity: AudioQueueEntityInput!, $sequence: Int) {\n    audioQueueItems: addAudioQueueItem(entity: $entity, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n": types.AddPlaylistItemDocument,
    "\n  mutation MoveAudioQueueItem($id: ID!, $sequence: Int!) {\n    audioQueueItems: moveAudioQueueItem(id: $id, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n": types.MoveAudioQueueItemDocument,
    "\n  mutation RemoveAudioQueueItem($id: ID!) {\n    audioQueueItems: removeAudioQueueItem(id: $id) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n": types.RemoveAudioQueueItemDocument,
    "\n  mutation ClearAudioQueue {\n    audioQueueItems: clearAudioQueue {\n      id\n    }\n  }\n": types.ClearAudioQueueDocument,
    "\n  mutation ReorderAudioQueue($ids: [ID!]!) {\n    audioQueueItems: reorderAudioQueue(ids: $ids) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n": types.ReorderAudioQueueDocument,
    "\n  query LatestArticles($count: Int!, $after: String) {\n    latestArticles: documents(first: $count, after: $after) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        id\n        meta {\n          title\n          path\n          publishDate\n          image\n          audioCoverCrop {\n            x\n            y\n            width\n            height\n          }\n          coverSm: audioCover(properties: { width: 128, height: 128 })\n          audioSource {\n            mediaId\n            kind\n            mp3\n            aac\n            ogg\n            durationMs\n            userProgress {\n              id\n              secs\n            }\n          }\n          format {\n            id\n            meta {\n              title\n              color\n              shareLogo\n              shareBackgroundImage\n              shareBackgroundImageInverted\n            }\n          }\n        }\n      }\n    }\n  }\n": types.LatestArticlesDocument,
    "\n  query mediaProgress($mediaId: ID!) {\n    mediaProgress(mediaId: $mediaId) {\n      id\n      mediaId\n      secs\n    }\n  }\n": types.MediaProgressDocument,
    "\n  mutation upsertMediaProgress($mediaId: ID!, $secs: Float!) {\n    upsertMediaProgress(mediaId: $mediaId, secs: $secs) {\n      id\n      mediaId\n      secs\n    }\n  }\n": types.UpsertMediaProgressDocument,
    "\nfragment BookmarkOnDocument on Document {\n  userBookmark: userCollectionItem(collectionName: \"\") {\n    id\n    createdAt\n  }\n}\n": types.BookmarkOnDocumentFragmentDoc,
    "\n  mutation acknowledgeCTA($id: ID!, $response: JSON) {\n    acknowledgeCallToAction(id: $id, response: $response) {\n      id\n      acknowledgedAt\n    }\n  }\n": types.AcknowledgeCtaDocument,
    "\n  query myCallToActions {\n    me {\n      id\n      callToActions {\n        id\n        beginAt\n        endAt\n        acknowledgedAt\n        payload {\n          ... on CallToActionBasicPayload {\n            text\n            linkHref\n            linkLabel\n          }\n\n          ... on CallToActionComponentPayload {\n            customComponent {\n              key\n              args\n            }\n          }\n        }\n      }\n    }\n  }\n": types.MyCallToActionsDocument,
    "\n  query postcardsQuestionnaire {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n      }\n    }\n  }\n": types.PostcardsQuestionnaireDocument,
    "\n  query postcardsStats($answers: [SubmissionFilterAnswer!]!) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      postcard_1: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_1\"\n      ) {\n        totalCount\n      }\n      postcard_2: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_2\"\n      ) {\n        totalCount\n      }\n      postcard_3: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_3\"\n      ) {\n        totalCount\n      }\n      postcard_4: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_4\"\n      ) {\n        totalCount\n      }\n    }\n  }\n": types.PostcardsStatsDocument,
    "\n  fragment PostcardConnection on SubmissionConnection {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      id\n      displayAuthor {\n        name\n        anonymity\n      }\n      answers {\n        nodes {\n          id\n          payload\n        }\n      }\n    }\n  }\n\n  query publicPostcardsQuery(\n    $includeHighlightedPostcardIds: [ID!]\n    $ignoreNotHighlightedPostcardIds: [ID!]\n    $answers: [SubmissionFilterAnswer!]!\n    $cursorHighlighted: String\n    $cursorNotHighlighted: String\n    $limit: Int\n    $valueHighlighted: String\n    $valueNotHighlighted: String\n  ) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n        ... on QuestionTypeImageChoice {\n          options {\n            value\n            imageUrl\n          }\n        }\n      }\n\n      highlighted: submissions(\n        first: $limit\n        after: $cursorHighlighted\n        filters: {\n          submissionIds: $includeHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueHighlighted\n      ) {\n        ...PostcardConnection\n      }\n\n      notHighlighted: submissions(\n        first: $limit\n        after: $cursorNotHighlighted\n        filters: {\n          notSubmissionIds: $ignoreNotHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueNotHighlighted\n      ) {\n        ...PostcardConnection\n      }\n    }\n  }\n": types.PostcardConnectionFragmentDoc,
    "\n  fragment Comment on Comment {\n    id\n    text\n    content\n    published\n    adminUnpublished\n    featuredAt\n    featuredText\n    featuredTargets\n    downVotes\n    upVotes\n    userVote\n    userCanEdit\n    userCanReport\n    userReportedAt\n    numReports\n    displayAuthor {\n      id\n      name\n      slug\n      profilePicture\n      credential {\n        id\n        description\n        verified\n      }\n    }\n    unreadNotifications {\n      nodes {\n        ...notificationInfo\n      }\n    }\n    embed {\n      ... on LinkPreview {\n        url\n        title\n        description\n        imageUrl\n        imageAlt\n        siteName\n        siteImageUrl\n        updatedAt\n        __typename\n      }\n      ... on TwitterEmbed {\n        id\n        url\n        text\n        html\n        userName\n        userScreenName\n        userProfileImageUrl\n        image\n        createdAt\n        __typename\n      }\n    }\n    updatedAt\n    createdAt\n    parentIds\n    tags\n    mentioningDocument {\n      iconUrl\n      document {\n        id\n        meta {\n          path\n        }\n      }\n      fragmentId\n    }\n  }\n\n  fragment notificationInfo on Notification {\n    id\n    readAt\n    createdAt\n  }\n": types.CommentFragmentDoc,
    "\n  fragment Discussion on Discussion {\n    id\n    title\n    document {\n      id\n      meta {\n        title\n        path\n        twitterImage\n        template\n        publishDate\n        ownDiscussion {\n          id\n          closed\n        }\n        linkedDiscussion {\n          id\n          path\n          closed\n        }\n      }\n    }\n    path\n    closed\n    isBoard\n    userPreference {\n      anonymity\n      credential {\n        id\n        description\n        verified\n      }\n      notifications\n    }\n    rules {\n      maxLength\n      minInterval\n      anonymity\n      disableTopLevelComments\n    }\n    userWaitUntil\n    userCanComment\n    displayAuthor {\n      id\n      name\n      slug\n      credential {\n        id\n        description\n        verified\n      }\n      profilePicture\n    }\n    collapsable\n    tagRequired\n    tags\n    tagBuckets {\n      value\n      count\n    }\n  }\n": types.DiscussionFragmentDoc,
    "\n  mutation featureCommentMutation(\n    $commentId: ID!\n    $content: String\n    $targets: [CommentFeaturedTarget!]\n  ) {\n    featureComment(id: $commentId, content: $content, targets: $targets) {\n      ...Comment\n    }\n  }\n  \n": types.FeatureCommentMutationDocument,
    "\n  mutation submitComment(\n    $discussionId: ID!\n    $parentId: ID\n    $id: ID!\n    $content: String!\n    $tags: [String!]!\n  ) {\n    submitComment(\n      id: $id\n      discussionId: $discussionId\n      parentId: $parentId\n      content: $content\n      tags: $tags\n    ) {\n      ...Comment\n      discussion {\n        id\n        userPreference {\n          notifications\n        }\n        userWaitUntil\n      }\n    }\n  }\n  \n": types.SubmitCommentDocument,
    "\n  query discussionPreferences($discussionId: ID!) {\n    me {\n      id\n      name\n      portrait\n      credentials {\n        id\n        description\n        verified\n        isListed\n      }\n      defaultDiscussionNotificationOption\n      discussionNotificationChannels\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n    }\n  }\n  \n": types.DiscussionPreferencesDocument,
    "\n  query discussion(\n    $discussionId: ID!\n    $parentId: ID\n    $after: String\n    $orderBy: DiscussionOrder!\n    $depth: Int!\n    $focusId: ID\n    $includeParent: Boolean\n    $activeTag: String\n  ) {\n    me {\n      id\n      name\n      portrait\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n      allComments: comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n      ) {\n        totalCount\n      }\n      comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n        tag: $activeTag\n      ) {\n        totalCount\n        resolvedOrderBy\n        directTotalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        focus {\n          id\n          parentIds\n          preview(length: 300) {\n            string\n          }\n          displayAuthor {\n            id\n            name\n          }\n        }\n        nodes {\n          ...Comment\n          comments {\n            totalCount\n            directTotalCount\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n": types.DiscussionDocument,
    "\n  query commentPreview(\n    $discussionId: ID!\n    $content: String!\n    $parentId: ID\n    $id: ID\n    $tags: [String!]\n  ) {\n    commentPreview(\n      content: $content\n      discussionId: $discussionId\n      parentId: $parentId\n      id: $id\n      tags: $tags\n    ) {\n      id\n      content\n      contentLength\n      tags\n      updatedAt\n      createdAt\n      embed {\n        ... on LinkPreview {\n          url\n          title\n          description\n          imageUrl\n          imageAlt\n          siteName\n          siteImageUrl\n          updatedAt\n          __typename\n        }\n        ... on TwitterEmbed {\n          id\n          url\n          text\n          html\n          userName\n          userScreenName\n          userProfileImageUrl\n          image\n          createdAt\n          __typename\n        }\n      }\n    }\n  }\n": types.CommentPreviewDocument,
    "\n  fragment UserProgressOnDocument on Document {\n    userProgress {\n      id\n      percentage\n      nodeId\n      updatedAt\n      max {\n        id\n        percentage\n        updatedAt\n      }\n    }\n  }\n": types.UserProgressOnDocumentFragmentDoc,
    "\n  fragment FeedDocument on Document {\n    id\n    repoId\n    ...BookmarkOnDocument\n    ...UserProgressOnDocument\n    meta {\n      credits\n      title\n      description\n      publishDate\n      prepublication\n      path\n      kind\n      template\n      color\n      estimatedReadingMinutes\n      estimatedConsumptionMinutes\n      indicateChart\n      indicateGallery\n      indicateVideo\n      audioSource {\n        mp3\n        aac\n        ogg\n        mediaId\n        durationMs\n        kind\n      }\n      dossier {\n        id\n      }\n      format {\n        id\n        meta {\n          path\n          title\n          color\n          kind\n          externalBaseUrl\n        }\n      }\n      ownDiscussion {\n        id\n        closed\n        comments {\n          totalCount\n        }\n      }\n      linkedDiscussion {\n        id\n        path\n        closed\n        comments {\n          totalCount\n        }\n      }\n      series {\n        title\n        episodes {\n          label\n          document {\n            id\n            repoId\n            meta {\n              path\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n": types.FeedDocumentFragmentDoc,
    "\n  query flyerNavi($publishedAt: DateTime!, $repoId: String!) {\n    prev: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          to: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: DESC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n    next: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          from: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: ASC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n  }\n": types.FlyerNaviDocument,
    "\n  query getFront(\n    $path: String!\n    $first: Int!\n    $after: ID\n    $before: ID\n    $only: ID\n  ) {\n    front: document(path: $path) {\n      id\n      children(first: $first, after: $after, before: $before, only: $only) {\n        totalCount\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n        }\n      }\n      meta {\n        path\n        title\n        description\n        image\n        facebookDescription\n        facebookImage\n        facebookTitle\n        twitterDescription\n        twitterImage\n        twitterTitle\n        prepublication\n        lastPublishedAt\n      }\n    }\n  }\n": types.GetFrontDocument,
    "\n  query getDocumentAudio($path: String!) {\n    document(path: $path) {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioSource {\n          mp3\n          aac\n          ogg\n          mediaId\n          durationMs\n          kind\n        }\n      }\n    }\n  }\n": types.GetDocumentAudioDocument,
    "\n  query MarketingPage {\n    carousel: document(path: \"/marketing\") {\n      id\n      content\n    }\n    carpet: document(path: \"/\") {\n      id\n      children(first: 40) {\n        nodes {\n          body\n        }\n      }\n    }\n    team: employees(withBoosted: true, shuffle: 3, withPitch: true) {\n      title\n      name\n      group\n      subgroup\n      pitch\n      user {\n        id\n        portrait\n        slug\n      }\n    }\n    featuredComments: comments(\n      orderBy: FEATURED_AT\n      orderDirection: DESC\n      first: 2\n      featuredTarget: MARKETING\n    ) {\n      id\n      nodes {\n        id\n        featuredText\n        createdAt\n        updatedAt\n        displayAuthor {\n          id\n          name\n          slug\n          credential {\n            id\n            description\n            verified\n          }\n          profilePicture\n        }\n        discussion {\n          id\n          title\n          path\n          comments(first: 0) {\n            totalCount\n          }\n          document {\n            id\n            meta {\n              format {\n                id\n              }\n              path\n              image\n              shareText\n            }\n          }\n        }\n      }\n    }\n  }\n": types.MarketingPageDocument,
    "\n  mutation reportUser($userId: ID!, $reason: String!) {\n    reportUser(userId: $userId, reason: $reason)\n  }\n": types.ReportUserDocument,
    "\n        query getRedirect($path: String!) {\n          redirection(path: $path) {\n            target\n            status\n          }\n        }\n      ": types.GetRedirectDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  \n  query getArticleRecommendations($path: String!) {\n    article: document(path: $path) {\n      id\n      meta {\n        recommendations {\n          nodes {\n            ...FeedDocument\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  \n  query getArticleRecommendations($path: String!) {\n    article: document(path: $path) {\n      id\n      meta {\n        recommendations {\n          nodes {\n            ...FeedDocument\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment AudioQueueItemFragment on AudioQueueItem {\n    id\n    sequence\n    document {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioCoverCrop {\n          x\n          y\n          width\n          height\n        }\n        coverForNativeApp: audioCover(properties: { width: 1024, height: 1024 })\n        coverMd: audioCover(properties: { width: 256, height: 256 })\n        coverSm: audioCover(properties: { width: 128, height: 128 })\n        audioSource {\n          mediaId\n          kind\n          mp3\n          aac\n          ogg\n          durationMs\n        }\n        format {\n          id\n          meta {\n            title\n            color\n            shareLogo\n            shareBackgroundImage\n            shareBackgroundImageInverted\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment AudioQueueItemFragment on AudioQueueItem {\n    id\n    sequence\n    document {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioCoverCrop {\n          x\n          y\n          width\n          height\n        }\n        coverForNativeApp: audioCover(properties: { width: 1024, height: 1024 })\n        coverMd: audioCover(properties: { width: 256, height: 256 })\n        coverSm: audioCover(properties: { width: 128, height: 128 })\n        audioSource {\n          mediaId\n          kind\n          mp3\n          aac\n          ogg\n          durationMs\n        }\n        format {\n          id\n          meta {\n            title\n            color\n            shareLogo\n            shareBackgroundImage\n            shareBackgroundImageInverted\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query GetAudioQueue {\n    me {\n      id\n      audioQueue {\n        ...AudioQueueItemFragment\n      }\n    }\n  }\n  \n"): (typeof documents)["\n  query GetAudioQueue {\n    me {\n      id\n      audioQueue {\n        ...AudioQueueItemFragment\n      }\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation AddPlaylistItem($entity: AudioQueueEntityInput!, $sequence: Int) {\n    audioQueueItems: addAudioQueueItem(entity: $entity, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"): (typeof documents)["\n  mutation AddPlaylistItem($entity: AudioQueueEntityInput!, $sequence: Int) {\n    audioQueueItems: addAudioQueueItem(entity: $entity, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation MoveAudioQueueItem($id: ID!, $sequence: Int!) {\n    audioQueueItems: moveAudioQueueItem(id: $id, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"): (typeof documents)["\n  mutation MoveAudioQueueItem($id: ID!, $sequence: Int!) {\n    audioQueueItems: moveAudioQueueItem(id: $id, sequence: $sequence) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation RemoveAudioQueueItem($id: ID!) {\n    audioQueueItems: removeAudioQueueItem(id: $id) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"): (typeof documents)["\n  mutation RemoveAudioQueueItem($id: ID!) {\n    audioQueueItems: removeAudioQueueItem(id: $id) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation ClearAudioQueue {\n    audioQueueItems: clearAudioQueue {\n      id\n    }\n  }\n"): (typeof documents)["\n  mutation ClearAudioQueue {\n    audioQueueItems: clearAudioQueue {\n      id\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation ReorderAudioQueue($ids: [ID!]!) {\n    audioQueueItems: reorderAudioQueue(ids: $ids) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"): (typeof documents)["\n  mutation ReorderAudioQueue($ids: [ID!]!) {\n    audioQueueItems: reorderAudioQueue(ids: $ids) {\n      ...AudioQueueItemFragment\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query LatestArticles($count: Int!, $after: String) {\n    latestArticles: documents(first: $count, after: $after) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        id\n        meta {\n          title\n          path\n          publishDate\n          image\n          audioCoverCrop {\n            x\n            y\n            width\n            height\n          }\n          coverSm: audioCover(properties: { width: 128, height: 128 })\n          audioSource {\n            mediaId\n            kind\n            mp3\n            aac\n            ogg\n            durationMs\n            userProgress {\n              id\n              secs\n            }\n          }\n          format {\n            id\n            meta {\n              title\n              color\n              shareLogo\n              shareBackgroundImage\n              shareBackgroundImageInverted\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query LatestArticles($count: Int!, $after: String) {\n    latestArticles: documents(first: $count, after: $after) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        id\n        meta {\n          title\n          path\n          publishDate\n          image\n          audioCoverCrop {\n            x\n            y\n            width\n            height\n          }\n          coverSm: audioCover(properties: { width: 128, height: 128 })\n          audioSource {\n            mediaId\n            kind\n            mp3\n            aac\n            ogg\n            durationMs\n            userProgress {\n              id\n              secs\n            }\n          }\n          format {\n            id\n            meta {\n              title\n              color\n              shareLogo\n              shareBackgroundImage\n              shareBackgroundImageInverted\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query mediaProgress($mediaId: ID!) {\n    mediaProgress(mediaId: $mediaId) {\n      id\n      mediaId\n      secs\n    }\n  }\n"): (typeof documents)["\n  query mediaProgress($mediaId: ID!) {\n    mediaProgress(mediaId: $mediaId) {\n      id\n      mediaId\n      secs\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation upsertMediaProgress($mediaId: ID!, $secs: Float!) {\n    upsertMediaProgress(mediaId: $mediaId, secs: $secs) {\n      id\n      mediaId\n      secs\n    }\n  }\n"): (typeof documents)["\n  mutation upsertMediaProgress($mediaId: ID!, $secs: Float!) {\n    upsertMediaProgress(mediaId: $mediaId, secs: $secs) {\n      id\n      mediaId\n      secs\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\nfragment BookmarkOnDocument on Document {\n  userBookmark: userCollectionItem(collectionName: \"\") {\n    id\n    createdAt\n  }\n}\n"): (typeof documents)["\nfragment BookmarkOnDocument on Document {\n  userBookmark: userCollectionItem(collectionName: \"\") {\n    id\n    createdAt\n  }\n}\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation acknowledgeCTA($id: ID!, $response: JSON) {\n    acknowledgeCallToAction(id: $id, response: $response) {\n      id\n      acknowledgedAt\n    }\n  }\n"): (typeof documents)["\n  mutation acknowledgeCTA($id: ID!, $response: JSON) {\n    acknowledgeCallToAction(id: $id, response: $response) {\n      id\n      acknowledgedAt\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query myCallToActions {\n    me {\n      id\n      callToActions {\n        id\n        beginAt\n        endAt\n        acknowledgedAt\n        payload {\n          ... on CallToActionBasicPayload {\n            text\n            linkHref\n            linkLabel\n          }\n\n          ... on CallToActionComponentPayload {\n            customComponent {\n              key\n              args\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query myCallToActions {\n    me {\n      id\n      callToActions {\n        id\n        beginAt\n        endAt\n        acknowledgedAt\n        payload {\n          ... on CallToActionBasicPayload {\n            text\n            linkHref\n            linkLabel\n          }\n\n          ... on CallToActionComponentPayload {\n            customComponent {\n              key\n              args\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query postcardsQuestionnaire {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n      }\n    }\n  }\n"): (typeof documents)["\n  query postcardsQuestionnaire {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query postcardsStats($answers: [SubmissionFilterAnswer!]!) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      postcard_1: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_1\"\n      ) {\n        totalCount\n      }\n      postcard_2: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_2\"\n      ) {\n        totalCount\n      }\n      postcard_3: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_3\"\n      ) {\n        totalCount\n      }\n      postcard_4: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_4\"\n      ) {\n        totalCount\n      }\n    }\n  }\n"): (typeof documents)["\n  query postcardsStats($answers: [SubmissionFilterAnswer!]!) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      postcard_1: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_1\"\n      ) {\n        totalCount\n      }\n      postcard_2: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_2\"\n      ) {\n        totalCount\n      }\n      postcard_3: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_3\"\n      ) {\n        totalCount\n      }\n      postcard_4: submissions(\n        filters: { answers: $answers }\n        value: \"postcard_4\"\n      ) {\n        totalCount\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment PostcardConnection on SubmissionConnection {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      id\n      displayAuthor {\n        name\n        anonymity\n      }\n      answers {\n        nodes {\n          id\n          payload\n        }\n      }\n    }\n  }\n\n  query publicPostcardsQuery(\n    $includeHighlightedPostcardIds: [ID!]\n    $ignoreNotHighlightedPostcardIds: [ID!]\n    $answers: [SubmissionFilterAnswer!]!\n    $cursorHighlighted: String\n    $cursorNotHighlighted: String\n    $limit: Int\n    $valueHighlighted: String\n    $valueNotHighlighted: String\n  ) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n        ... on QuestionTypeImageChoice {\n          options {\n            value\n            imageUrl\n          }\n        }\n      }\n\n      highlighted: submissions(\n        first: $limit\n        after: $cursorHighlighted\n        filters: {\n          submissionIds: $includeHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueHighlighted\n      ) {\n        ...PostcardConnection\n      }\n\n      notHighlighted: submissions(\n        first: $limit\n        after: $cursorNotHighlighted\n        filters: {\n          notSubmissionIds: $ignoreNotHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueNotHighlighted\n      ) {\n        ...PostcardConnection\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment PostcardConnection on SubmissionConnection {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      id\n      displayAuthor {\n        name\n        anonymity\n      }\n      answers {\n        nodes {\n          id\n          payload\n        }\n      }\n    }\n  }\n\n  query publicPostcardsQuery(\n    $includeHighlightedPostcardIds: [ID!]\n    $ignoreNotHighlightedPostcardIds: [ID!]\n    $answers: [SubmissionFilterAnswer!]!\n    $cursorHighlighted: String\n    $cursorNotHighlighted: String\n    $limit: Int\n    $valueHighlighted: String\n    $valueNotHighlighted: String\n  ) {\n    questionnaire(slug: \"klima-postkarte\") {\n      id\n      questions {\n        id\n        ... on QuestionTypeImageChoice {\n          options {\n            value\n            imageUrl\n          }\n        }\n      }\n\n      highlighted: submissions(\n        first: $limit\n        after: $cursorHighlighted\n        filters: {\n          submissionIds: $includeHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueHighlighted\n      ) {\n        ...PostcardConnection\n      }\n\n      notHighlighted: submissions(\n        first: $limit\n        after: $cursorNotHighlighted\n        filters: {\n          notSubmissionIds: $ignoreNotHighlightedPostcardIds\n          answers: $answers\n        }\n        value: $valueNotHighlighted\n      ) {\n        ...PostcardConnection\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment Comment on Comment {\n    id\n    text\n    content\n    published\n    adminUnpublished\n    featuredAt\n    featuredText\n    featuredTargets\n    downVotes\n    upVotes\n    userVote\n    userCanEdit\n    userCanReport\n    userReportedAt\n    numReports\n    displayAuthor {\n      id\n      name\n      slug\n      profilePicture\n      credential {\n        id\n        description\n        verified\n      }\n    }\n    unreadNotifications {\n      nodes {\n        ...notificationInfo\n      }\n    }\n    embed {\n      ... on LinkPreview {\n        url\n        title\n        description\n        imageUrl\n        imageAlt\n        siteName\n        siteImageUrl\n        updatedAt\n        __typename\n      }\n      ... on TwitterEmbed {\n        id\n        url\n        text\n        html\n        userName\n        userScreenName\n        userProfileImageUrl\n        image\n        createdAt\n        __typename\n      }\n    }\n    updatedAt\n    createdAt\n    parentIds\n    tags\n    mentioningDocument {\n      iconUrl\n      document {\n        id\n        meta {\n          path\n        }\n      }\n      fragmentId\n    }\n  }\n\n  fragment notificationInfo on Notification {\n    id\n    readAt\n    createdAt\n  }\n"): (typeof documents)["\n  fragment Comment on Comment {\n    id\n    text\n    content\n    published\n    adminUnpublished\n    featuredAt\n    featuredText\n    featuredTargets\n    downVotes\n    upVotes\n    userVote\n    userCanEdit\n    userCanReport\n    userReportedAt\n    numReports\n    displayAuthor {\n      id\n      name\n      slug\n      profilePicture\n      credential {\n        id\n        description\n        verified\n      }\n    }\n    unreadNotifications {\n      nodes {\n        ...notificationInfo\n      }\n    }\n    embed {\n      ... on LinkPreview {\n        url\n        title\n        description\n        imageUrl\n        imageAlt\n        siteName\n        siteImageUrl\n        updatedAt\n        __typename\n      }\n      ... on TwitterEmbed {\n        id\n        url\n        text\n        html\n        userName\n        userScreenName\n        userProfileImageUrl\n        image\n        createdAt\n        __typename\n      }\n    }\n    updatedAt\n    createdAt\n    parentIds\n    tags\n    mentioningDocument {\n      iconUrl\n      document {\n        id\n        meta {\n          path\n        }\n      }\n      fragmentId\n    }\n  }\n\n  fragment notificationInfo on Notification {\n    id\n    readAt\n    createdAt\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment Discussion on Discussion {\n    id\n    title\n    document {\n      id\n      meta {\n        title\n        path\n        twitterImage\n        template\n        publishDate\n        ownDiscussion {\n          id\n          closed\n        }\n        linkedDiscussion {\n          id\n          path\n          closed\n        }\n      }\n    }\n    path\n    closed\n    isBoard\n    userPreference {\n      anonymity\n      credential {\n        id\n        description\n        verified\n      }\n      notifications\n    }\n    rules {\n      maxLength\n      minInterval\n      anonymity\n      disableTopLevelComments\n    }\n    userWaitUntil\n    userCanComment\n    displayAuthor {\n      id\n      name\n      slug\n      credential {\n        id\n        description\n        verified\n      }\n      profilePicture\n    }\n    collapsable\n    tagRequired\n    tags\n    tagBuckets {\n      value\n      count\n    }\n  }\n"): (typeof documents)["\n  fragment Discussion on Discussion {\n    id\n    title\n    document {\n      id\n      meta {\n        title\n        path\n        twitterImage\n        template\n        publishDate\n        ownDiscussion {\n          id\n          closed\n        }\n        linkedDiscussion {\n          id\n          path\n          closed\n        }\n      }\n    }\n    path\n    closed\n    isBoard\n    userPreference {\n      anonymity\n      credential {\n        id\n        description\n        verified\n      }\n      notifications\n    }\n    rules {\n      maxLength\n      minInterval\n      anonymity\n      disableTopLevelComments\n    }\n    userWaitUntil\n    userCanComment\n    displayAuthor {\n      id\n      name\n      slug\n      credential {\n        id\n        description\n        verified\n      }\n      profilePicture\n    }\n    collapsable\n    tagRequired\n    tags\n    tagBuckets {\n      value\n      count\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation featureCommentMutation(\n    $commentId: ID!\n    $content: String\n    $targets: [CommentFeaturedTarget!]\n  ) {\n    featureComment(id: $commentId, content: $content, targets: $targets) {\n      ...Comment\n    }\n  }\n  \n"): (typeof documents)["\n  mutation featureCommentMutation(\n    $commentId: ID!\n    $content: String\n    $targets: [CommentFeaturedTarget!]\n  ) {\n    featureComment(id: $commentId, content: $content, targets: $targets) {\n      ...Comment\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation submitComment(\n    $discussionId: ID!\n    $parentId: ID\n    $id: ID!\n    $content: String!\n    $tags: [String!]!\n  ) {\n    submitComment(\n      id: $id\n      discussionId: $discussionId\n      parentId: $parentId\n      content: $content\n      tags: $tags\n    ) {\n      ...Comment\n      discussion {\n        id\n        userPreference {\n          notifications\n        }\n        userWaitUntil\n      }\n    }\n  }\n  \n"): (typeof documents)["\n  mutation submitComment(\n    $discussionId: ID!\n    $parentId: ID\n    $id: ID!\n    $content: String!\n    $tags: [String!]!\n  ) {\n    submitComment(\n      id: $id\n      discussionId: $discussionId\n      parentId: $parentId\n      content: $content\n      tags: $tags\n    ) {\n      ...Comment\n      discussion {\n        id\n        userPreference {\n          notifications\n        }\n        userWaitUntil\n      }\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query discussionPreferences($discussionId: ID!) {\n    me {\n      id\n      name\n      portrait\n      credentials {\n        id\n        description\n        verified\n        isListed\n      }\n      defaultDiscussionNotificationOption\n      discussionNotificationChannels\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n    }\n  }\n  \n"): (typeof documents)["\n  query discussionPreferences($discussionId: ID!) {\n    me {\n      id\n      name\n      portrait\n      credentials {\n        id\n        description\n        verified\n        isListed\n      }\n      defaultDiscussionNotificationOption\n      discussionNotificationChannels\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n    }\n  }\n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query discussion(\n    $discussionId: ID!\n    $parentId: ID\n    $after: String\n    $orderBy: DiscussionOrder!\n    $depth: Int!\n    $focusId: ID\n    $includeParent: Boolean\n    $activeTag: String\n  ) {\n    me {\n      id\n      name\n      portrait\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n      allComments: comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n      ) {\n        totalCount\n      }\n      comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n        tag: $activeTag\n      ) {\n        totalCount\n        resolvedOrderBy\n        directTotalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        focus {\n          id\n          parentIds\n          preview(length: 300) {\n            string\n          }\n          displayAuthor {\n            id\n            name\n          }\n        }\n        nodes {\n          ...Comment\n          comments {\n            totalCount\n            directTotalCount\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n"): (typeof documents)["\n  query discussion(\n    $discussionId: ID!\n    $parentId: ID\n    $after: String\n    $orderBy: DiscussionOrder!\n    $depth: Int!\n    $focusId: ID\n    $includeParent: Boolean\n    $activeTag: String\n  ) {\n    me {\n      id\n      name\n      portrait\n    }\n    discussion(id: $discussionId) {\n      ...Discussion\n      allComments: comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n      ) {\n        totalCount\n      }\n      comments(\n        parentId: $parentId\n        after: $after\n        orderBy: $orderBy\n        first: 100\n        flatDepth: $depth\n        focusId: $focusId\n        includeParent: $includeParent\n        tag: $activeTag\n      ) {\n        totalCount\n        resolvedOrderBy\n        directTotalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        focus {\n          id\n          parentIds\n          preview(length: 300) {\n            string\n          }\n          displayAuthor {\n            id\n            name\n          }\n        }\n        nodes {\n          ...Comment\n          comments {\n            totalCount\n            directTotalCount\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query commentPreview(\n    $discussionId: ID!\n    $content: String!\n    $parentId: ID\n    $id: ID\n    $tags: [String!]\n  ) {\n    commentPreview(\n      content: $content\n      discussionId: $discussionId\n      parentId: $parentId\n      id: $id\n      tags: $tags\n    ) {\n      id\n      content\n      contentLength\n      tags\n      updatedAt\n      createdAt\n      embed {\n        ... on LinkPreview {\n          url\n          title\n          description\n          imageUrl\n          imageAlt\n          siteName\n          siteImageUrl\n          updatedAt\n          __typename\n        }\n        ... on TwitterEmbed {\n          id\n          url\n          text\n          html\n          userName\n          userScreenName\n          userProfileImageUrl\n          image\n          createdAt\n          __typename\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query commentPreview(\n    $discussionId: ID!\n    $content: String!\n    $parentId: ID\n    $id: ID\n    $tags: [String!]\n  ) {\n    commentPreview(\n      content: $content\n      discussionId: $discussionId\n      parentId: $parentId\n      id: $id\n      tags: $tags\n    ) {\n      id\n      content\n      contentLength\n      tags\n      updatedAt\n      createdAt\n      embed {\n        ... on LinkPreview {\n          url\n          title\n          description\n          imageUrl\n          imageAlt\n          siteName\n          siteImageUrl\n          updatedAt\n          __typename\n        }\n        ... on TwitterEmbed {\n          id\n          url\n          text\n          html\n          userName\n          userScreenName\n          userProfileImageUrl\n          image\n          createdAt\n          __typename\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment UserProgressOnDocument on Document {\n    userProgress {\n      id\n      percentage\n      nodeId\n      updatedAt\n      max {\n        id\n        percentage\n        updatedAt\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment UserProgressOnDocument on Document {\n    userProgress {\n      id\n      percentage\n      nodeId\n      updatedAt\n      max {\n        id\n        percentage\n        updatedAt\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  fragment FeedDocument on Document {\n    id\n    repoId\n    ...BookmarkOnDocument\n    ...UserProgressOnDocument\n    meta {\n      credits\n      title\n      description\n      publishDate\n      prepublication\n      path\n      kind\n      template\n      color\n      estimatedReadingMinutes\n      estimatedConsumptionMinutes\n      indicateChart\n      indicateGallery\n      indicateVideo\n      audioSource {\n        mp3\n        aac\n        ogg\n        mediaId\n        durationMs\n        kind\n      }\n      dossier {\n        id\n      }\n      format {\n        id\n        meta {\n          path\n          title\n          color\n          kind\n          externalBaseUrl\n        }\n      }\n      ownDiscussion {\n        id\n        closed\n        comments {\n          totalCount\n        }\n      }\n      linkedDiscussion {\n        id\n        path\n        closed\n        comments {\n          totalCount\n        }\n      }\n      series {\n        title\n        episodes {\n          label\n          document {\n            id\n            repoId\n            meta {\n              path\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n"): (typeof documents)["\n  fragment FeedDocument on Document {\n    id\n    repoId\n    ...BookmarkOnDocument\n    ...UserProgressOnDocument\n    meta {\n      credits\n      title\n      description\n      publishDate\n      prepublication\n      path\n      kind\n      template\n      color\n      estimatedReadingMinutes\n      estimatedConsumptionMinutes\n      indicateChart\n      indicateGallery\n      indicateVideo\n      audioSource {\n        mp3\n        aac\n        ogg\n        mediaId\n        durationMs\n        kind\n      }\n      dossier {\n        id\n      }\n      format {\n        id\n        meta {\n          path\n          title\n          color\n          kind\n          externalBaseUrl\n        }\n      }\n      ownDiscussion {\n        id\n        closed\n        comments {\n          totalCount\n        }\n      }\n      linkedDiscussion {\n        id\n        path\n        closed\n        comments {\n          totalCount\n        }\n      }\n      series {\n        title\n        episodes {\n          label\n          document {\n            id\n            repoId\n            meta {\n              path\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  \n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query flyerNavi($publishedAt: DateTime!, $repoId: String!) {\n    prev: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          to: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: DESC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n    next: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          from: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: ASC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query flyerNavi($publishedAt: DateTime!, $repoId: String!) {\n    prev: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          to: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: DESC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n    next: search(\n      first: 1\n      filter: {\n        publishedAt: {\n          from: $publishedAt\n        }\n      }\n      filters: [\n        { key: \"format\", value: \"\" }\n        { not: true, key: \"repoId\", value: $repoId }\n      ]\n      sort: {\n        key: publishedAt\n        direction: ASC\n      }\n    ) {\n      totalCount\n      nodes {\n        entity {\n          ... on Document {\n            id\n            meta {\n              path\n              title\n              publishDate\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query getFront(\n    $path: String!\n    $first: Int!\n    $after: ID\n    $before: ID\n    $only: ID\n  ) {\n    front: document(path: $path) {\n      id\n      children(first: $first, after: $after, before: $before, only: $only) {\n        totalCount\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n        }\n      }\n      meta {\n        path\n        title\n        description\n        image\n        facebookDescription\n        facebookImage\n        facebookTitle\n        twitterDescription\n        twitterImage\n        twitterTitle\n        prepublication\n        lastPublishedAt\n      }\n    }\n  }\n"): (typeof documents)["\n  query getFront(\n    $path: String!\n    $first: Int!\n    $after: ID\n    $before: ID\n    $only: ID\n  ) {\n    front: document(path: $path) {\n      id\n      children(first: $first, after: $after, before: $before, only: $only) {\n        totalCount\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n        }\n      }\n      meta {\n        path\n        title\n        description\n        image\n        facebookDescription\n        facebookImage\n        facebookTitle\n        twitterDescription\n        twitterImage\n        twitterTitle\n        prepublication\n        lastPublishedAt\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query getDocumentAudio($path: String!) {\n    document(path: $path) {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioSource {\n          mp3\n          aac\n          ogg\n          mediaId\n          durationMs\n          kind\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query getDocumentAudio($path: String!) {\n    document(path: $path) {\n      id\n      meta {\n        title\n        path\n        publishDate\n        image\n        audioSource {\n          mp3\n          aac\n          ogg\n          mediaId\n          durationMs\n          kind\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query MarketingPage {\n    carousel: document(path: \"/marketing\") {\n      id\n      content\n    }\n    carpet: document(path: \"/\") {\n      id\n      children(first: 40) {\n        nodes {\n          body\n        }\n      }\n    }\n    team: employees(withBoosted: true, shuffle: 3, withPitch: true) {\n      title\n      name\n      group\n      subgroup\n      pitch\n      user {\n        id\n        portrait\n        slug\n      }\n    }\n    featuredComments: comments(\n      orderBy: FEATURED_AT\n      orderDirection: DESC\n      first: 2\n      featuredTarget: MARKETING\n    ) {\n      id\n      nodes {\n        id\n        featuredText\n        createdAt\n        updatedAt\n        displayAuthor {\n          id\n          name\n          slug\n          credential {\n            id\n            description\n            verified\n          }\n          profilePicture\n        }\n        discussion {\n          id\n          title\n          path\n          comments(first: 0) {\n            totalCount\n          }\n          document {\n            id\n            meta {\n              format {\n                id\n              }\n              path\n              image\n              shareText\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query MarketingPage {\n    carousel: document(path: \"/marketing\") {\n      id\n      content\n    }\n    carpet: document(path: \"/\") {\n      id\n      children(first: 40) {\n        nodes {\n          body\n        }\n      }\n    }\n    team: employees(withBoosted: true, shuffle: 3, withPitch: true) {\n      title\n      name\n      group\n      subgroup\n      pitch\n      user {\n        id\n        portrait\n        slug\n      }\n    }\n    featuredComments: comments(\n      orderBy: FEATURED_AT\n      orderDirection: DESC\n      first: 2\n      featuredTarget: MARKETING\n    ) {\n      id\n      nodes {\n        id\n        featuredText\n        createdAt\n        updatedAt\n        displayAuthor {\n          id\n          name\n          slug\n          credential {\n            id\n            description\n            verified\n          }\n          profilePicture\n        }\n        discussion {\n          id\n          title\n          path\n          comments(first: 0) {\n            totalCount\n          }\n          document {\n            id\n            meta {\n              format {\n                id\n              }\n              path\n              image\n              shareText\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  mutation reportUser($userId: ID!, $reason: String!) {\n    reportUser(userId: $userId, reason: $reason)\n  }\n"): (typeof documents)["\n  mutation reportUser($userId: ID!, $reason: String!) {\n    reportUser(userId: $userId, reason: $reason)\n  }\n"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n        query getRedirect($path: String!) {\n          redirection(path: $path) {\n            target\n            status\n          }\n        }\n      "): (typeof documents)["\n        query getRedirect($path: String!) {\n          redirection(path: $path) {\n            target\n            status\n          }\n        }\n      "];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;